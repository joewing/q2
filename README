
## Frontpanel

  16 Address LEDs
  16 Data LEDs
  16 Toggle switches
  Buttons:
    - Reset/Set Address
    - Increment Address
    - Deposit
    - Start
    - Stop

## Boards

  Name        | Quantity  | Description
  Slice       | 16        | ALU/A/P/X slice
  RAM         | 1         | 16-bit RAM module
  Control     | 1         | Control module
  Clock       | 1         | Clock generator
  Backplane   | 1         | Backplane

### Clock Board

  Pin | Name        | Description
  --- | ----------- | -------------
  1   | VCC         | +5v
  2   | FAST_IN     | To fast clock switch
  3   | FAST_OUT    | To fast clock switch
  4   | START_IN    | Start switch
  5   | STOP_IN     | Stop switch
  6   | RST_IN      | Reset switch
  7   | HALT_IN     | Halt signal from control board
  8   | ~DEP_SW_IN  | Deposit switch
  9   | ~INCP_SW_IN | Increment P switch
  10  | ~RAM_CE_IO  | RAM CE bus (RAM enable)
  11  | ~RAM_WE_IO  | RAM WE bus (RAM write)
  12  | ~WRN_IO     | WRN bus (write next P)
  13  | ~WRP_IO     | WRP bus (load P from N)
  14  | WRN_OUT     | WRN signal to slice boards
  15  | WRP_OUT     | WRP signal to slice boards
  16  | RDSW_OUT    | Read switch signal to slice boards
  17  | N/C         | No connection
  18  | CLK1_OUT    | Clock phase 1
  19  | CLK2_OUT    | Clock phase 2
  20  | GND         | Ground

Note that pins 21-40 mirror 1-20.

### Control Board

  Pin | Name          | Description
  1   | VCC           | +5v
  2   | RDP_OUT       | Read P to DBUS
  3   | RDX_OUT       | Read X to ABUS
  4   | XHIN_ABUS_OUT | Read XH to ABUS



## Clock generation

A two phase, non-overlapping clock is generated using
a relaxation oscillator (CLK signal) tied to a master-slave
flip-flop.  Two NOR gates are used to generate the phases.
The output of the flip-flop is Q:

  CLK1 = ~(Q | CLK)
  CLK2 = ~(~Q | CLK)

When not running, CLK is high. At reset Q is set to 0.
This means that on reset we have CLK=1 and Q=0. Thus,
the starting sequence looks like this:

  RUN | RST | CLK | Q | C1 | C2 | Notes
  --- | --- | --- | - | -- | -- | --------------------------------
   0  |  1  |  1  | 0 |  0 |  0 | Reset button pressed
   0  |  0  |  1  | 0 |  0 |  0 | Reset button released
   1  |  0  |  0  | 0 |  1 |  0 | Run button pressed (and latched)
   1  |  0  |  1  | 1 |  0 |  0 |
   1  |  0  |  0  | 1 |  0 |  1 |
   1  |  0  |  1  | 0 |  0 |  0 |
   1  |  0  |  0  | 0 |  1 |  0 |


## Registers


  Name  | Size  | Description
  ----- | ----- | ----------------
  A     | 16    | Accumulator
  P     | 16    | Program counter
  X     | 16    | Operand
  O     | 6     | Opcode Latch (don't need to store Z)
  F     | 1     | Flag
  S     | 2     | State

## Instructions

  Instructions are 1 word.
             6 543 2 1 0
  Format is: T FFF L D Z XXXXXXXXX
  where:
    T     - type        - (0-load, 1-store)
    FFF   - function
    L     - load        - load from memory (instead of immediate)
    D     - dereference - dereference
    Z     - zero page   - use zero page for upper bits (instead of P)
    Xs    - 9-bit operand

  Instruction summary:

  Opcode  | Mnemonic  | F | Description
  ------- | --------- | - | ---------------------
  0000    | ld x      | Z | Load: A = x
  0001    | not x     | Z | NOT: A = ~x
  0010    | and x     | Z | AND: A = A & x
  0011    | or x      | Z | OR: A = A | x
  0100    | xor x     | Z | XOR: A = A ^ x
  0101    | add x     | C | Add: A = A + x
  0110    | sub x     | C | Subtract: A = A - x
  0111    | shr x     | C | Shift right: A = x >> 1
  1000    | nop       | - | No operation
  1001    | st x      | - | Store A: [x] = A
  1010    | jnf x     | - | Jump if zero/no carry (F not set)
  1011    | jf x      | - | Jump if not-zero/carry (F set)
  1100    | j x       | - | Jump: P = x
  1101    | unused    | - | Unused
  1110    | unused    | - | Unused
  1111    | halt x    | - | Wait for x

  The flag is set if carry ('C'), non-zero ('Z'),
  or left unchanged ('-').

  Address modes are indicated as follows:

    Value | ZLD | Meaning
    ----- | --- | ---------------
    #x    | 100 | immediate
    x     | 010 | current-page relative
    @x    | 011 | indirect through current page
    =x    | 110 | zero-page relative
    @=x   | 111 | indirect through zero page

  Note that store instructions do not set 'L'.

## Control Lines

  - RDP_ABUS = STATE_FETCH
  - RDX_ABUS = STATE_LOAD | STATE_DEFER | STATE_EXEC
  - WRO_DBUS = STATE_FETCH & WS
  - XHIN_ABUS = STATE_FETCH & DBUS[ZBIT]
  - XLIN_ABUS = 0
  - XHIN_DBUS = STATE_LOAD | STATE_DEREF
  - XLIN_DBUS = 1
  - WRX = (STATE_FETCH & WS)
        | (STATE_LOAD & WS & OP[LOAD_BIT])
        | (STATE_DEREF & WS & OP[DEREF_BIT])
  - WRA = WRF = STATE_EXEC & TYPE0 & WS
  - RDA_DBUS = STATE_EXEC & TYPE1 & FUNC1
  - PIN_NEXT = STATE_FETCH
  - PIN_X = STATE_EXEC
  - RDM_DBUS = ~STATE_EXEC
  - WRP = (STATE_FETCH & WS) | JUMP
        | (STATE_EXEC & TYPE1 & WS & FUNC4)
        | (STATE_EXEC & TYPE1 & WS & FUNC3 & F)
        | (STATE_EXEC & TYPE1 & WS & FUNC2 & ~F)
  - WRM_DBUS = STATE_EXEC & TYPE1 & WS & (FUNC1 | FUNC6)
  - HALT = STATE_EXEC & TYPE1 & FUNC7 & WS

## States

  - FETCH  - Fetch instruction
    - RDP_ABUS
    - RDM_DBUS
    - WRO_DBUS
    - XHIN_ABUS = DBUSL[Z_BIT]
    - XLIN_DBUS
    - WRX
    - PIN_NEXT
    - WRP
  - LOAD    - Load memory
    - RDX_ABUS
    - RDM_DBUS
    - XHIN_DBUS
    - XLIN_DBUS
    - WRX = O[LBIT]
  - DEREF   - Dereference
    - RDX_ABUS
    - RDM_DBUS
    - XHIN_DBUS
    - XLIN_DBUS
    - WRX = O[DBIT]
  - EXEC    - Execute
    - RDX_ABUS

## Examples

; Call a function
  ld    #+2   ; return pointer in A
  j     func
  ; function returns here

; Return to caller, return pointer in A
func:
  st    =ra
  ; do some stuff
  j     @=ra

; push =x onto the stack
; Return address in A.
; Assumes =x, =ra, and =sp are in the zero page.
; 7 words
push:
  st    =ra   ; save return address
  ld    =x    ; load value to save
  st    @=sp  ; save to the stack
  ld    =sp   ; load stack pointer
  sub   #1    ; decrement
  st    =sp   ; save updated stack pointer
  j     @=ra  ; return

; pop A off the stack
; Assumes =ra and =sp are in the zero page.
; 6 words
pop:
  st    =ra   ; save return address
  ld    =sp   ; load current stack pointer
  add   #1    ; increment
  st    =sp   ; save updated stack pointer
  ld    @=sp  ; load top of the stack
  j     @=ra  ; return

; Set =n bytes at =ptr to =x
; Destroys =n and =ptr
; Assumes A is the return address
; 11 words
memset:
  st    =ra   ; save return address
memset_loop:
  ld    =n    ; load current count
  jnf   @=ra  ; return if zero
  sub   #1    ; decrement
  st    =n    ; save updated count
  ld    =x    ; load value to save
  st    @=ptr ; save it
  ld    =ptr  ; increment pointer
  add   #1
  st    =ptr
  j     memset_loop

; Copy =src to =dest
; 11 words
strcpy:
  st    =ra
strcpy_loop:
  ld    @=src
  st    @=dest
  jnf   @=ra
  ld    =src
  add   #1
  st    =src
  ld    =dest
  add   #1
  st    =dest
  j     strcpy_loop

; Shift =x right =n bits
unsignedShiftRight:
  st    =ra
unsignedShiftRightLoop:
  ld    =n
  jnf   @=ra
  sub   #1
  st    =n
  shr   =x
  st    =x
  j     unsignedShiftRightLoop


; Add two 32 bit numbers, at =x and =y, result in =x (little-endian)
add32:
  st    =ra
  ld    =x
  add   =y
  st    =x
  jf    add32_carry
  ld    =x+1
  j     add32_cont
add32_carry:
  ld    =x+1
  add   #1
add32_cont:
  add   =y+1
  st    =x+1
  j     @=ra


